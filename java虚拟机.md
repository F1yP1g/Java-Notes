# 1 类的生命周期
类的完整生命周期：   
![](pic/类生命周期.png)   
系统加载 Class 类型的文件主要三步:**加载->连接->初始化**。连接过程又可分为三步:验证->准备->解析。

![](pic/类加载过程.png "类的加载过程")
1. 加载
   1. 通过全类名获取定义此类的二进制字节流
   2. 将字节流代表的静态存储结构转换为方法区的运行时数据结构
   3. 在内存中生成一个代表此类的 Class 对象，作为方法区这些数据的访问入口
   
   加载阶段和连接阶段部分内容是交叉进行的，加载还没结束时，连接阶段可能就已经开始了。
2. 验证   
   ![](pic/验证阶段.png)
3. 准备   
   准备阶段正式**为类变量分配内存**并设置类变量初始值。
4. 解析   
  解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。 
     - 符号引用就是一组符号来描述目标，可以是任何字面量。
     - 直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
5. 初始化   
   初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 `clinit()` 方法的过程。
6. 卸载   
   卸载类即该类的Class对象被GC。
   
   卸载类要满足三个要求：
    1. 该类的所有实例化对象都已被 GC，堆中不存在该类的实例对对象。
    2. 该类没有在其他任何地方被引用.
    3. 该类的类加载器的实例已被 GC.
# 2 Java 对象的创建过程
类加载检查 --> 分配内存 --> 初始化零值 --> 设置对象头 --> 执行 `init` 方法
1. 类加载检查   
检查 new 指令对应的参数是都能在常量池中定位到这个类的符号引用，并检查这个符号引用代表的类是都被加载过，如果没有，则先进行类加载过程。
2. 分配内存   
为新生对象分配内存
3. 初始化零值   
   将分配的内存空间都初始化为零值（除了对象头），保证对象的实例字段在代码中可以不赋初始值就直接使用。
4. 设置对象头   
   设置对象头，如对象是哪个类的实例、如何能找到类的元数据信息、对象的哈希码等等。
5. 执行 `init` 方法   
   此时从虚拟机的角度看，新的对象已经产生了，这一步执行 `init` 方法将对象按照程序员的意愿初始化。
# 3 引用
1. 强引用（StrongReference） 必不可少   
平常使用的引用，如果一个对象有强引用，垃圾回收器绝不会收它，即使内存不足抛出 `OutOfMemoryError` 也不会回收。
2. 软引用（SoftReference） 可有可无   
   如果一个对象只具有软引用，那么当内存空间不足时，会被回收。   
   软引用可用来实现内存敏感的高速缓存。
3. 弱引用（WeakReference） 可有可无   
   弱引用比软引用的对象生命周期更短暂。只要垃圾回收器的线程发现了只具有弱引用的对象，不管空间是否足够都会回收它。   
   不过垃圾回收器的线程优先级很低，不一定能很快发现这些对象。
4. 虚引用（PhantomReference）   
   ⼀个对象仅持有虚引⽤，那么它就和没有任何引⽤⼀样，在任何时候都可能被垃圾回收。
# 3 垃圾回收
垃圾收集主要是针对堆和方法区进行。程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后就会消失，因此不需要对这三个区域进行垃圾回收。
## 判断一个对象是否可被回收
1. 引用计数算法   
   为对象添加一个引用计数器，增加引用时计数器加 1，引用失效时计数器减 1，引用计数为 0 的对象可被回收。   
   缺点：两个对象循环引用时，引用计数器永不为 0，无法被回收。因此 Java 虚拟机中不适用该方法。
2. 可达性分析算法   
   以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收。   
   
   Java 虚拟机使用该算法来判断对象是否可被回收，GC Roots 一般包含以下内容：
   - 虚拟机栈中局部变量表中引用的对象
   - 本地方法栈中 JNI 中引用的对象
   - 方法区中类静态属性引用的对象
   - 方法区中的常量引用的对象

## 垃圾收集算法
1. 标记-清除   
   ![](pic/标记-清除.png)   
   在标记阶段，程序会检查每个对象是否为活动对象，如果是活动对象，则程序会在对象头部打上标记。
   
   在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

   缺点：
   - 标记和清楚效率都不高
   - 会产生大量不连续的内存碎片，导致无法给大对象分配内存
2. 标记-整理   
   ![](pic/标记-整理.png)   
    让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

    不会产生碎片，但需要移动大量对象，处理效率较低。   
3. 复制   
   ![](pic/复制.png)   
    将内存划分为大小相等的两块，每次只使用其中一块，当这一块内存用完了就将还存活的对象复制到另一块上面，然后再把使用过的内存空间进行一次清理。

    主要不足是只使用了内存的一半。

    现在的商业虚拟机都采用这种收集算法回收**新生代**，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。

4. 分代收集   
   现在的商业虚拟机采用分代收集算法，它根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。

    一般将堆分为新生代和老年代。
    - 新生代：复制算法
    - 老生代：标记-清除 或者 标记-整理
## 垃圾回收器
### CMS收集器
CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。

CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。

垃圾回收步骤：
   1. 初始标记： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；
   2. 并发标记： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。
   3. 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短
   4. 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。

![](pic/CMS收集器.png)

主要优点：并发收集、低停顿。但是它有下面三个明显的缺点：
   - 对 CPU 资源敏感；
   - 无法处理浮动垃圾；
   - 它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。
# 4 jvm 运行时数据区域

![](pic/JVM运行时数据区域.png)

在7以及之前堆和方法区连在了一起，但这并不能说堆和方法区是一起的，它们在逻辑上依旧是分开的。Java7及以前版本的Hotspot中方法区位于永久代中。

   >永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。

![](pic/堆和方法区.png)

java8之后，方法区（永久代）变为元空间,在Java8中，方法区存在于元空间(Metaspace)。

同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。[元空间和永久代](https://juejin.im/post/6844904020964802574)
   >元空间存在于本地内存，意味着只要本地内存足够，它不会出现像永久代中的 “java.lang.OutOfMemoryError: PermGenspace”错误

![](pic/2019-3Java运行时数据区域JDK1.8.png)

### java 虚拟机栈
Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。

Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。

![](pic/栈帧.png)

**局部变量表**主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

Java 虚拟机栈会出现两种错误：`StackOverFlowError` 和 `OutOfMemoryError`。
   - `StackOverFlowError`： 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。
   - `OutOfMemoryError`： 若 Java 虚拟机堆中没有空闲内存，并且垃圾回收器也无法提供更多内存的话。就会抛出 OutOfMemoryError 错误。

### 堆
所有线程共享的内存区域，在虚拟机启动时创建。

**此内存区域的唯一目的就是存放对象实例，*几乎*所有的对象实例以及数组都在这里分配内存。**
   >随着JIT编译期的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从jdk 1.7开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。
JDK 7 版本及JDK 7 版本之前，堆内存被通常被分为下面三部分：
   1. 新生代
   2. 老生代
   3. 永生代
![](pic/JVM堆内存结构-JDK7.png)

JDK 7之后方法去彻底移除换位元空间，使用直接内存。
### 方法区
方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

方法区和永久代的关系：
   >《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。
### 运行时常量池
运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）

除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。